### Гайд по написанию тестов (bun:test)

Этот документ описывает, как писать юнит/интеграционные тесты для бэкенда с использованием bun:test, очищать БД перед тестами, подготавливать данные и проверять бизнес-логику сделок и балансов.

### Общие правила
- Все названия тестов пишите на русском.
- Перед каждым тестовым сьютом очищайте только релевантные данные, созданные в сьютах (или используйте транзакции/фикстуры).
- Генерируйте тестовые сущности строго через публичные эндпоинты, если проверяем их контракт. Прямое создание через БД допустимо только для данных-фикстур (мерчант, метод, трейдер, реквизиты), не являющихся предметом тестируемого контракта.
- Для динамических ожиданий (например, курс берётся из источника) — подтягивайте источник (например, `rapiraService.getUsdtRubRate()`) в момент проверки. Не хардкодьте числа.
- Над каждым тестом оставляйте компактный комментарий с ожидаемым результатом: что создастся/не создастся, сколько заморозится, что вернётся при истечении, какой профит начислится при подтверждении, и т.д.

### Организация окружения
- Используйте `Elysia` и реальные роуты (`merchantRoutes`, `adminRoutes`, `traderRoutes`) там, где проверяется публичный контракт, иначе — напрямую `db`.
- Для аутентификации:
  - Мерчант: заголовок `x-merchant-api-key`.
  - Админ: заголовок `x-admin-key` (см. middleware/guards; в тестах можно замокать `adminGuard` аналогично существующим тестам).
  - Трейдер: заголовок `x-trader-token`.

### Очистка БД
- Используйте `afterAll` для удаления созданных сущностей: `db.transaction.deleteMany`, `db.bankDetail.deleteMany`, `db.traderMerchant.deleteMany`, `db.merchant.deleteMany`, `db.method.deleteMany`, `db.user.deleteMany`, и пр.
- Для больших сьютов допускается логическая «метка» в данных (например, по имени/коду с префиксом), чтобы удалить всё, что создано в сьюте.

### Изоляция тестов (обязательно)
- Между тестами используйте `beforeEach`/`afterEach` для сброса летучего состояния:
  - Удаляйте «живые» сущности текущего сьюта: `transaction`, `transactionAttempt`, `notification`.
  - Сбрасывайте состояния трейдера к базовым: `frozenUsdt = 0`, `trustBalance = стартовое значение`.
  - Сбрасывайте настройки комиссий/режимов: например, `traderMerchant.feeIn = 0`, `useFlexibleRates = false`.
- Не изменяйте балансы напрямую внутри сценариев в середине сьюта (например, не обнуляйте `frozenUsdt` руками) — это ведёт к отрицательным значениям при «разморозке». Любые корректировки состояния — только в `beforeEach/afterEach`.
- Каждый тест должен полагаться только на данные, которые сам создал, и на базовую фикстуру сьюта.

### Фикстуры (рекомендации)
- Создавайте:
  - Мерчанта (включая привязку метода через `merchantMethod`).
  - Метод с нужным `type` и `currency`.
  - Трейдера с достаточным `trustBalance` и включённым трафиком.
  - Связку `traderMerchant` с нужными флагами (`isMerchantEnabled`, `isFeeInEnabled`).
  - Реквизиты (`bankDetail`) с лимитами (`minAmount`, `maxAmount`, `operationLimit`, `sumLimit`, `intervalMinutes`) и привязкой устройства при необходимости.

### Что проверять для /merchant/transactions/in
- Подбор реквизита: по лимитам суммы, активность, устройство, интервал, дубликаты по сумме, лимиты по количеству и сумме.
- Логику источников курса: сохранённый в сделке `rate` — из `getTraderRate`; `merchantRate` — из тела или конфигурации источника мерчанта.
- Заморозку: строго проверяйте 2 разных округления:
  - В транзакции `frozenUsdtAmount` = floor(amount/rate, 2) — отсечение до двух знаков (пример: 73.6293 → 73.62).
  - У трейдера на профиле при списании/разморозке используется округление вверх до двух знаков (ceil2): 73.6293 → 73.63.
  - При EXPIRED возврат на `trustBalance` и уменьшение `frozenUsdt` происходит на сумму ceil2(floor2(amount/rate)).
- Ответ API: корректный статус 201 и поля (`id`, `amount`, `status`, `traderId`, `requisites`, `expired_at`, `method`, и т.п.).

### Истечение и подтверждение
- Истечение: через административный эндпоинт изменения статуса (`/admin/transactions/:id/status`) установите `EXPIRED` и проверьте возврат замороженных средств на `trustBalance`.
- Подтверждение:
  - Вариант 1 (админ): `/admin/transactions/:id/status` на `READY` и проверьте зачисления (мерчанту), изменения заморозки/прибылей.
  - Вариант 2 (трейдер): `/trader/transactions/:id/status` на `READY` — расчёты должны совпадать по формулам; сравните с вариантом 1 для одинаковых входных данных.

### Нагрузочные сценарии
- Массовые запросы: отправьте 1000 параллельных запросов на создание, при этом `operationLimit` на реквизите установите в 10. Ожидайте, что будет создано не более 10 активных сделок по одному реквизиту, остальные вернут ошибку `409 NO_REQUISITE`.

### Оформление комментариев над тестами (пример)
// Ожидаемо: создаётся сделка IN на 10 000₽, выбирается реквизит А,
// заморозка: floor(10000 / rate, 2), списание с trustBalance на эту сумму,
// ответ: 201 и валидные поля.

// Ожидаемо: при истечении сделки — разморозка = ранее замороженная сумма,
// возврат в trustBalance, статус EXPIRED, трейдерский баланс обновлён.

// Ожидаемо: при подтверждении READY — начисление мерчанту netAmount/rate,
// профит трейдера по гибкой ставке, корректная финальная заморозка.


